/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace NotesApp {
  export type NoteStruct = {
    owner: AddressLike;
    title: string;
    encryptedContent: BytesLike;
    tags: string;
    isFavourite: boolean;
    createdAt: BigNumberish;
    updatedAt: BigNumberish;
    exists: boolean;
  };

  export type NoteStructOutput = [
    owner: string,
    title: string,
    encryptedContent: string,
    tags: string,
    isFavourite: boolean,
    createdAt: bigint,
    updatedAt: bigint,
    exists: boolean
  ] & {
    owner: string;
    title: string;
    encryptedContent: string;
    tags: string;
    isFavourite: boolean;
    createdAt: bigint;
    updatedAt: bigint;
    exists: boolean;
  };
}

export interface NotesAppInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "createNote"
      | "deleteNote"
      | "getNote"
      | "getUserNoteCount"
      | "getUserNotes"
      | "noteCount"
      | "toggleFavourite"
      | "updateNote"
      | "userNotes"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "NoteCreated"
      | "NoteDeleted"
      | "NoteFavouriteToggled"
      | "NoteUpdated"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "createNote",
    values: [string, BytesLike, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteNote",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getNote",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserNoteCount",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserNotes",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "noteCount",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "toggleFavourite",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateNote",
    values: [BigNumberish, string, BytesLike, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "userNotes",
    values: [AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "createNote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deleteNote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getNote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getUserNoteCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserNotes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "noteCount", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "toggleFavourite",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "updateNote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "userNotes", data: BytesLike): Result;
}

export namespace NoteCreatedEvent {
  export type InputTuple = [
    owner: AddressLike,
    noteId: BigNumberish,
    title: string
  ];
  export type OutputTuple = [owner: string, noteId: bigint, title: string];
  export interface OutputObject {
    owner: string;
    noteId: bigint;
    title: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NoteDeletedEvent {
  export type InputTuple = [owner: AddressLike, noteId: BigNumberish];
  export type OutputTuple = [owner: string, noteId: bigint];
  export interface OutputObject {
    owner: string;
    noteId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NoteFavouriteToggledEvent {
  export type InputTuple = [
    owner: AddressLike,
    noteId: BigNumberish,
    isFavourite: boolean
  ];
  export type OutputTuple = [
    owner: string,
    noteId: bigint,
    isFavourite: boolean
  ];
  export interface OutputObject {
    owner: string;
    noteId: bigint;
    isFavourite: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NoteUpdatedEvent {
  export type InputTuple = [
    owner: AddressLike,
    noteId: BigNumberish,
    title: string
  ];
  export type OutputTuple = [owner: string, noteId: bigint, title: string];
  export interface OutputObject {
    owner: string;
    noteId: bigint;
    title: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface NotesApp extends BaseContract {
  connect(runner?: ContractRunner | null): NotesApp;
  waitForDeployment(): Promise<this>;

  interface: NotesAppInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  createNote: TypedContractMethod<
    [title: string, encryptedContent: BytesLike, tags: string, arg3: BytesLike],
    [void],
    "nonpayable"
  >;

  deleteNote: TypedContractMethod<[noteId: BigNumberish], [void], "nonpayable">;

  getNote: TypedContractMethod<
    [user: AddressLike, noteId: BigNumberish],
    [NotesApp.NoteStructOutput],
    "view"
  >;

  getUserNoteCount: TypedContractMethod<[user: AddressLike], [bigint], "view">;

  getUserNotes: TypedContractMethod<
    [user: AddressLike],
    [NotesApp.NoteStructOutput[]],
    "view"
  >;

  noteCount: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  toggleFavourite: TypedContractMethod<
    [noteId: BigNumberish],
    [void],
    "nonpayable"
  >;

  updateNote: TypedContractMethod<
    [
      noteId: BigNumberish,
      title: string,
      encryptedContent: BytesLike,
      tags: string,
      arg4: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  userNotes: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [string, string, string, string, boolean, bigint, bigint, boolean] & {
        owner: string;
        title: string;
        encryptedContent: string;
        tags: string;
        isFavourite: boolean;
        createdAt: bigint;
        updatedAt: bigint;
        exists: boolean;
      }
    ],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "createNote"
  ): TypedContractMethod<
    [title: string, encryptedContent: BytesLike, tags: string, arg3: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "deleteNote"
  ): TypedContractMethod<[noteId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getNote"
  ): TypedContractMethod<
    [user: AddressLike, noteId: BigNumberish],
    [NotesApp.NoteStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserNoteCount"
  ): TypedContractMethod<[user: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getUserNotes"
  ): TypedContractMethod<
    [user: AddressLike],
    [NotesApp.NoteStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "noteCount"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "toggleFavourite"
  ): TypedContractMethod<[noteId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateNote"
  ): TypedContractMethod<
    [
      noteId: BigNumberish,
      title: string,
      encryptedContent: BytesLike,
      tags: string,
      arg4: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "userNotes"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [string, string, string, string, boolean, bigint, bigint, boolean] & {
        owner: string;
        title: string;
        encryptedContent: string;
        tags: string;
        isFavourite: boolean;
        createdAt: bigint;
        updatedAt: bigint;
        exists: boolean;
      }
    ],
    "view"
  >;

  getEvent(
    key: "NoteCreated"
  ): TypedContractEvent<
    NoteCreatedEvent.InputTuple,
    NoteCreatedEvent.OutputTuple,
    NoteCreatedEvent.OutputObject
  >;
  getEvent(
    key: "NoteDeleted"
  ): TypedContractEvent<
    NoteDeletedEvent.InputTuple,
    NoteDeletedEvent.OutputTuple,
    NoteDeletedEvent.OutputObject
  >;
  getEvent(
    key: "NoteFavouriteToggled"
  ): TypedContractEvent<
    NoteFavouriteToggledEvent.InputTuple,
    NoteFavouriteToggledEvent.OutputTuple,
    NoteFavouriteToggledEvent.OutputObject
  >;
  getEvent(
    key: "NoteUpdated"
  ): TypedContractEvent<
    NoteUpdatedEvent.InputTuple,
    NoteUpdatedEvent.OutputTuple,
    NoteUpdatedEvent.OutputObject
  >;

  filters: {
    "NoteCreated(address,uint256,string)": TypedContractEvent<
      NoteCreatedEvent.InputTuple,
      NoteCreatedEvent.OutputTuple,
      NoteCreatedEvent.OutputObject
    >;
    NoteCreated: TypedContractEvent<
      NoteCreatedEvent.InputTuple,
      NoteCreatedEvent.OutputTuple,
      NoteCreatedEvent.OutputObject
    >;

    "NoteDeleted(address,uint256)": TypedContractEvent<
      NoteDeletedEvent.InputTuple,
      NoteDeletedEvent.OutputTuple,
      NoteDeletedEvent.OutputObject
    >;
    NoteDeleted: TypedContractEvent<
      NoteDeletedEvent.InputTuple,
      NoteDeletedEvent.OutputTuple,
      NoteDeletedEvent.OutputObject
    >;

    "NoteFavouriteToggled(address,uint256,bool)": TypedContractEvent<
      NoteFavouriteToggledEvent.InputTuple,
      NoteFavouriteToggledEvent.OutputTuple,
      NoteFavouriteToggledEvent.OutputObject
    >;
    NoteFavouriteToggled: TypedContractEvent<
      NoteFavouriteToggledEvent.InputTuple,
      NoteFavouriteToggledEvent.OutputTuple,
      NoteFavouriteToggledEvent.OutputObject
    >;

    "NoteUpdated(address,uint256,string)": TypedContractEvent<
      NoteUpdatedEvent.InputTuple,
      NoteUpdatedEvent.OutputTuple,
      NoteUpdatedEvent.OutputObject
    >;
    NoteUpdated: TypedContractEvent<
      NoteUpdatedEvent.InputTuple,
      NoteUpdatedEvent.OutputTuple,
      NoteUpdatedEvent.OutputObject
    >;
  };
}
